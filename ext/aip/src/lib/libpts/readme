Patricia tree storage
---------------------

Краткое описание компонент.

pat_tree.h и pat_tree.c
-----------------------

Реализация алгоритма PATRICIA (Practical Algorithm to Retrieval
Information Coded in Alphanumeric) для хронения строк символов
(pat_char), заканчивающимеся специальным символом PAT_CHAR_FINISH. На
самом деле, подходит для обычных ASCIIZ-строк (PAT_CHAR_FINISH ---
нулевой символ). 

Свойства:

1. Позволяет присвоить уникальной строке уникальный номер
   (pat_tree_append), найти строку в дереве (pat_tree_lookup), причем
   найти как точное совпадение (PAT_LOOKUP_EXACT_MATCH), так и
   наиболее близкое префиксное совпдадение
   (PAT_LOOKUP_BEST_MATCH). Кроме того, наличие обратного индекса
   позволяет быстро найти по индентификатору строку. Все
   идентификаторы раздаются начиная с 1 в порядке добавления новых
   строк. 

2. Возможность сохранения данных в компактном транспортном формате и
   формате, готовом для использования в оперативной
   памяти. Транспортный формат переносим между различными
   архитектурами (все целые числа хранятся в сетевом порядке байт). 

3. По сравнению со структурами STLport:

   а. со стандартным аллокатаром памяти: в два-три раза быстрее чем
      std::map<std::string, unsigned int>, в полтора-два раза быстрее чем
      std::hash_map<std::string, unsigned int> (имеется в виду, в
      режиме read-write с заполнением массивов). 

   б. с новым аллокатором памяти --- в полтора раза быстрее
      std::hash_map и в два раза быстрее map.

   в. по памяти: в режиме read-write после заполнения дерева по RSS в
      FreeBSD занимает примерно столько же, сколько и map, и в полтора
      раза больше, чем hash_map. После подъема файла с данными,
      сохраненными в формате, готовом для использования в оперативной
      памяти, занимает в два раза меньше, чем hash_map (заполненный
      изначала) --- за счет отсутствия издержек на realloc. 

4. Реально же, на каждое вхождение тратится дополнительно по 16 байт
   на узлах дерева (ссылка вправо, влево, количество бит на пропуск,
   идентификатор элемента). Теоретически, можно ужать до 12
   байт. Плюс, все узлы выравнены по 4 байта (данные хранятся в узлах
   для ускорения доступа к ним). На самом деле, хранить данные в узлах
   для PATRICIA не очень правильно, алгоритм предназначен для быстрого
   поиска подходящего узла в индексе и подъеме его один раз из
   медленной памяти (с жесткого диска). Если такое поведение
   понадобится, то его очень легко получить; пока что же область
   использования такова, что удобнее хранить данные непосредственно в
   ключах. Кроме того, исключение данных из ключей приведет именно к
   той же экономии до 12 байт на узел (и фиксированного размера
   узла). 

Интерфейс описан на языке C в HEAD/alk/libpts/pat_tree.h и 
HEAD/alk/libpts/pat_types.h

Пример использования --- HEAD/alk/libpts/pt_test.c


pts.h и pts.c
-------------

Библиотека Patricia Tree Storage, предназначена для использования в
морфологиях в качестве хранилища данных.

Позволяет:

1. Сохранять данные в транспортном или быстром форматах данных.

2. Для быстрого формата данных позволяет загрузить данные через модуль
   shared_file и использовать имеющиеся данные как разделяемые между
   процессами под Unix. При этом сохраняется возможность добавлять
   данные в личную память процесса с наращиванием идентификаторов. 
   Новые данные можно быстро сбросить (уничтожить), но нельзя
   сохранить в файл (так как он находится в общем доступе).

3. В качестве разделяемого формата данных используется pat_tree. В
   качестве личного формата данных тоже используется pat_tree, хотя
   было бы логичнее использовать для временных внутренних данных
   что-нибудь вроде хорошего хеша. Но пока что сойдет и так. 

Интерфейс описан на языке C в HEAD/alk/libpts/pts.h и 
HEAD/alk/libpts/pat_types.h.

Пример использования --- HEAD/alk/libpts/pts_test.c
