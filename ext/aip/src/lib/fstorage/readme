Универсальное хранилище данных
------------------------------
Краткое описание

                                                      Калинин А.Л.,
                                                         01.02.05

1. Предназначение хранилища
---------------------------

Хранилище предназначено для организации данных СпамТеста. Хранилище
поддерживает разделение данных на секции, загрузку и выгрузку их как в
разделяемом с другими процессами режиме (через механизм mmap), так и
изменение данных при открытии в эксклюзивном режиме. 

1.1. Основные характеристики
----------------------------

Хранилище состоит из секций, каждое из которых характеризуется своим
уникальным номером. Номера задаются в файле fstorage_ids.h при помощи
макросов. Действует соглашение, что приложение, которому выделен
какой-то номер секции, может использовать кроме него по своему
усмотрению и следующие 15 (то есть, номера секций выделяются блоками
по 16 штук).  

Может быть выделен и более крупный блок (например, под лингвистический
процессор с морфологиями), более подробно занятые номера описаны в
fstorage_id.h. Автоматической проверки корректности ведения
идентификаторов не предусмотрено. 

Формат хранилища не зависит от операционной системы или архитектуры
компьютера. 

Секции хранилища и внутренние данные хранилиза (заголовки и прочее),
всегда выравнены по 32 байта.

1.2. Принципы использования
---------------------------

При создании хранилища учитывались два варианта его использования:

 --- использование хранилища для "рабочих" данных. Рабочие данные
     готовы к непосредственному использованию в приложениях, содержат
     в себе необходимые индексы и не предназначены для переноса за
     пределы компьютера, на котором были собраны. То есть, рабочие
     данные можно сохранять буквально в том же виде, в каком
     представляются внутри программы (например, массив структур)
     вместе с выравниванием.

 --- "транспортный формат", наоборот, не предназначен для
     непосредственного использования, а содержит только необходимую
     информацию для конвертирования данных в рабочий
     формат. Транспортный формат мобилен, не зависит от архитектуры
     ЭВМ и настроек компилятора. 

2. Интерфейс
------------

Интерфейс содержится в файле lib/fstorage/fstorage.h. C++-обертки
нет. 

2.1. Функции работы с хранилищем
--------------------------------

Хранилище представляется в программах при помощи типа fstorage,
который во внешнем интерфейсе не определен (то есть, могут
существовать только указатели на этот объект).

2.1.1. Создание объекта
-----------------------

Для получения нового объекта используется функция

    fstorage *fstorage_create();

Данный объект не связан с реальным хранилищем на жестком диске, поэтому
использовать его невозможно (любая попытка будет выдавать ошибку
FSTORAGE_ERROR_INVALID_MODE).

Функция возвращает корректный указатель или NULL в случае какой-либо
ошибки. 

2.1.2. Разрушение объекта
-------------------------

Созданный при помощи fstorage_create объект должен быть обязательно
разрушен функцией

    int       fstorage_destroy(fstorage *fs);

Если объект был связан с файлом на жестком диске, то сохранения не
происходит. 

2.1.4. Последняя ошибка
-----------------------

Если хранилище создано, то всегда можно получить код последней ошибки,
возникшей в результате операций над хранилищем. Для этого используется
функция

    int fstorage_last_error(fstorage *fs);

Ошибки кодируются константами перечисления fstorage_errors:

    enum fstorage_errors
    {
        FSTORAGE_OK                   =  0,  /* no error */
        FSTORAGE_ERROR_INVALID_PARAMS = -1,  /* invalid call parameters, 
                                              * i.e hfs == NOSTORAGE */
        FSTORAGE_ERROR_INVALID_MODE   = -2,  /* action is not possible in current open mode 
                                              * or storage is not opened */
        FSTORAGE_ERROR_NOSECTION      = -3,  /* no section with given id */
        FSTORAGE_ERROR_NOMEMORY       = -4,  /* no memory to allocate internal buffer */
        FSTORAGE_ERROR_INVALID_FILE   = -5,  /* file is not fstorage */
        FSTORAGE_ERROR_INVALID_VERS   = -6,  /* invalid fstorage version or project_id */
        FSTORAGE_ERROR_OPEN           = -7,  /* system error while opening file */
        FSTORAGE_ERROR_READ           = -8,  /* system error while reading data from file */
        FSTORAGE_ERROR_WRITE          = -9,  /* system error while writing data to file */
        FSTORAGE_ERROR_UNKNOWN        = -10  /* internal program error */
    };

Все функции, возвращающие целочисленные значения, в случае отсутствия
ошибки возвращают FSTORAGE_OK. Отрицательный возврат свидетельствует о
возникшей ошибке с соответствующим кодом. 

FSTORAGE_ERROR_INVALID_PARAMS
   Возникает в случае передачи неверных аргументов (например, нулевого
   указателя в качестве хранилища).

FSTORAGE_ERROR_INVALID_MODE
   Данная операция не может быть выполнена в текущем режиме (например,
   сохранение хранилища в режиме "только для чтения").
   
FSTORAGE_ERROR_NOSECTION
   Секция с данным номером не была найдена в хранилище. 

FSTORAGE_ERROR_NOMEMORY
   Возникла ошибка с выделением памяти (malloc вернул NULL).

FSTORAGE_ERROR_INVALID_FILE
   Открываемый файл не является хранилищем. 

FSTORAGE_ERROR_INVALID_VERS
   Требуемая версия библиотеки не подходит для данного хранилища, или
   не совпадает номер проекта. 

FSTORAGE_ERROR_OPEN
   Возникла системная ошибка открытия файла. 

FSTORAGE_ERROR_READ
   Возникла системная ошибка при чтении из файла.

FSTORAGE_ERROR_WRITE
   Возникла системная ошибка при записи в файл. 

FSTORAGE_ERROR_UNKNOWN
   Ошибка в программном обеспечении. 

2.1.5. Связывание объекта с файлом на жестком диске
---------------------------------------------------

Использование хранилища возможно только после явного связывания его с
местом хранения. На текущий момент возможно связать хранилище только с
файлом. Для этого используется функция низкого уровня

    int fstorage_connect(fstorage *fs, const char *path, int open_flags, int open_mode, 
                        enum fstorage_open_modes fsom, struct fstorage_connect_config *fscc);

Ее параметры:

 --- fs, указатель на объект хранилища.

 --- path, имя файла.

 --- open_flags, второй аргумент функции open(2), флаги открытия файла.

 --- open_mode, третий аргумент функции open(2), режим доступа.

 --- fsom, режим открытия хранилища. Может принимать следующие
     значения:

        * FSTORAGE_OPEN_READ_ONLY, хранилище открыто только для
          чтения.

        * FSTORAGE_OPEN_READ_WRITE, хранилище открыто для чтения и
          записи. 

 --- fscc, указатель на структуру конфигурации хранилища. Сейчас
     доступен только один параметр, fscc->pid, номер
     проекта. Хранилище может быть открыто только при совпадении этого
     номера с сохраненным.  

Функция возвращает FSTORAGE_OK в случае успеха, или FSTORAGE_ERROR_* в
случае ошибки. 

Примеры использования функции fstorage_connect:

 --- Создание нового хранилища:

             fstorage *fs = fstorage_create();
             struct fstorage_connect_config fscc;

             memset(&fscc, 0, sizeof(fscc));

             fscc.pid = FSTORAGE_PID_TEST;

             if(fstorage_connect(fs, storage_name, O_CREAT | O_TRUNC | O_RDWR, 0644, FSTORAGE_OPEN_READ_WRITE, &fscc))
                 {
                     
                     fprintf(stderr, "Couldn't create storage %s.\n", storage_name);
                     exit(1);
                 }

     Будет создано новое хранилище (в случае, если оно уже было, оно
     обнулится из-за флага O_TRUNC).

 --- Открытие существующего хранилища для чтения-записи:

             fstorage *fs = fstorage_create();
             struct fstorage_connect_config fscc;

             memset(&fscc, 0, sizeof(fscc));
             
             fscc.pid = FSTORAGE_PID_TEST;

             if(fstorage_connect(fs, storage_name, O_RDWR, 0644, FSTORAGE_OPEN_READ_WRITE, &fscc))
                 {
                     
                     fprintf(stderr, "Couldn't load storage %s.\n", storage_name);
                     exit(1);
                 }

 --- Открытие существующего хранилища только для чтения:

             fstorage *fs = fstorage_create();
             struct fstorage_connect_config fscc;

             memset(&fscc, 0, sizeof(fscc));
             
             fscc.pid = FSTORAGE_PID_TEST;

             if(fstorage_connect(fs, storage_name, O_RDONLY, 0644, FSTORAGE_OPEN_READ_WRITE, &fscc))
                 {
                     
                     fprintf(stderr, "Couldn't load storage %s.\n", storage_name);
                     exit(1);
                 }


2.1.6. Связывание объекта с файлом на жестком диске в разделяемом режиме
------------------------------------------------------------------------

Хранилище может быть разделено между несколькими процессами,
рабоютающими с ним в режиме "только для чтения". Для разделения данных
нужно воспользоваться следующей функцией:

    int fstorage_connect_shared(fstorage *fs, const char *path, struct fstorage_connect_config *fscc);

Все три параметра имеют аналогичный смысл соответствующим параметрам
fstorage_connect. Такие параметры, как fsom, open_flags и open_mode не
передаются, потому что выставляются особым способом внутри
fstorage_connect_shared. 

2.1.7. Закрытие хранилища
-------------------------

После произведения окончания работы хранилищем (не с объектом, а
именно с данными, хранящимеся во внешнем файле), его нужно закрыть или
отменить изменения. 

Для закрытия используется функция

    int fstorage_close(fstorage *fs);

Если хранилище было открыто в режиме "чтение-запись" то происходит
запись секций в хранилище (переписывание старого файла). В режиме
"только чтение" исходный файл никак не меняется.

2.1.8. Отмена изменений
-----------------------

Функция 

    int fstorage_purge(fstorage *fs);

аналогична fstorage_close, но не трогает исходный файл в любом
случае. 

На самом деле, если хранилище было открыто с флагом O_TRUNC, то
исходный файл будет уничтожен в любом случае при операции связывания
объекта хранилища с файлом (fstorage_connect).

2.1.9. Получить имя файла
-------------------------

Функция 

    const char *fstorage_get_path(fstorage *fs);

позволяет получить название файла (asciiz-строка), с которым связано
хранилище. 

2.1.10. Получить режим хранилища
--------------------------------

Функция 

    enum fstorage_open_modes fstorage_open_mode(fstorage *fs);

возвращает режим, в котором было открыто хранилище. Возвращаемые
значения:

        * FSTORAGE_OPEN_CLOSED, хранилище закрыто.

        * FSTORAGE_OPEN_READ_ONLY, хранилище открыто в режиме только
          для чтения.

        * FSTORAGE_OPEN_READ_WRITE, хранилище доступно для изменений. 

2.1.11. Проверка разделяемости данных
-------------------------------------

Функция

    int fstorage_is_shared(fstorage *fs);

возвращает ненулевое значение в случае, если хранилище открыто при
помощи fstorage_connect_shared и его данные разделяются между
процессами, которые используют данное хранилище.

2.1.12. Совместное использование хранилища внутри нескольких потоков
--------------------------------------------------------------------

Хранилище можно разделять между потоками только в том случае, когда
оно было связано с файлом при помощи функции
fstorage_connect_shared. Тогда каждый поток может получить собственную
копию объекта хранилища при помощи функции

    fstorage *fstorage_clone(fstorage *fs);

которая возвращает внутренний для данного потока объект хранилища,
разделяющий данные с исходным. Поток должен закрыть объект и
уничтожить его обычным способом (fstorage_close, fstorage_destroy). 

Хранилище учитывает ссылки на себя и уничтожается только в том случае,
если счетчик ссылок стал равен нулю.

ЗАМЕЧАНИЕ. На самом деле, этот вызов и совместная работа нескольких
потоков с отдельным хранилищем до сих пор серьезно не тестировалась. 

2.2. Манипулирование секциями
-----------------------------

После того, как хранилище связано с файлом, можно производить операции
над секциями (создавать, удалять, получать доступ к памяти и т.п.)

Секция характеризуется своим номером. Для доступа к секции
используются указатели на объекты fstorage_section.

Идентификаторы секции --- константы типа section_id, среди которых
выделена специальная константа FSTORAGE_SECTION_NONE. Секций с таким
номером не может существовать, запрос на создании секции с номером
FSTORAGE_SECTION_NONE является ошибкой. Получение такого
идентификатора из хранилища свидетельствует об ошибке. 

2.2.1. Создание новой секции
----------------------------

Для создания новой секции (с уникальным идентификатором) используется
функция 

    fstorage_section *fstorage_section_create(fstorage *fs, section_id sid);

Ее параметры:

 --- fs, хранилище.

 --- sid, идентификатор секции. Если секция с таким идентификатором
     уже существует, новая секция не будет создана, а
     fstorage_section_create вернет NULL.

Функция возвращает NULL в случае ошибки или указатель на объект
fstorage_section в случае успеха. Полученный объект не требует
уничтожения со стороны пользователя. 

2.2.2. Удаление секции
----------------------

Для удаления секции из хранилища используется функция

    int fstorage_remove_section(fstorage *fs, section_id sid);

2.2.3. Поиск секции в хранилище
-------------------------------

Для поиска секций используются следующие функции:

    fstorage_section   *fstorage_get_first_section(fstorage *fs);

Позволяет получить первую секцию в хранилище (без соблюдения
какого-либо порядка по идентификаторам). 

    fstorage_section   *fstorage_next_section(fstorage_section *fsect);

Позволяет получить следующую секцию по внутреннему порядку внутри
хранилища. 

    fstorage_section   *fstorage_find_section(fstorage *fs, section_id sid);

Позволяет найти существующую секцию по ее номеру.

Все функции возвращают NULL в случае неудачи.

2.2.4. Информация, связаная с секцией
-------------------------------------

Функция

    section_id  fstorage_section_get_id(fstorage_section *fss);

позволяет получить номер секции, связанной с объектом fstorage_section.

Функция

    fstorage   *fstorage_section_get_fs(fstorage_section *fss);

возвращает хранилище, которому принадлежит секция. 

2.2.5. Загрузка секции
----------------------

Функции

    int         fstorage_load_section(fstorage *fs, section_id sid);
    int         fstorage_section_load(fstorage_section *fss);

явно загружают данные секции в оперативную память. Вызов обязателен
для потоковых секций. Отличие между двумя вызовами заключается в
способе идентификации секции (через хранилище и номер, или через
полученный ранее объект fstorage_section).

2.2.6. Доступ к данным секции
-----------------------------

Функция 

    size_t      fstorage_section_get_size(fstorage_section *fss);

возвращает размер данных, хранимых на текущий момент в
секции. 

Функция 

    void  *fstorage_section_get_data(fstorage_section *fss, size_t offset, size_t amount);

используется для получения данных из секции. Ее параметры:

 --- fss, секция, к данным которым требуется доступ.

 --- offset, смещение внутри секции требуемых данных.

 --- amount, количество байтов от смещения offset, которые требуются.

Функция возвращает указатель на данные, которыми можно пользоваться.

Для получения указателя на все данные, сопоставленные с секцией,
используется функция 

    void  *fstorage_section_get_all_data(fstorage_section *fss);

Если данные не были загружены ранее, то они загружаются (для
непотококвых функций). 

Функция

    int    fstorage_section_realloc(fstorage_section *fss, size_t size);

используется для изменения размера секции с сохранением данных внутри
ее (аналог realloc). После ее использования следует обновить все
указатели, полученные ранее при помощи функций get_data.

Функция 

    int    fstorage_section_copy_data(fstorage_section *fss, void *data, size_t size);

используется замещения текущих данных секции на переданные
снаружи. Память выделяется внутри хранилища.

Функция 

    int    fstorage_section_set_data(fstorage_section *fss, void *data, size_t size);

аналогична fstorage_section_copy_data за исключением того, что
хранилище не выделяет память, а использует переданные
указатели. Хозяин переданной памяти не может удалить ее до тех пор,
пока она не перестанет быть нужна хранилищу (в противном случае,
хранилище не сможет корректно функционировать). 

2.2.7. Потоковые секции
-----------------------

Для оптимизации работы с транспортным форматом возможно использование
потоков при обработке секций. Потоковые секции не загружаются в память
непосредственно, вместо этого при вызове fstorage_section_load (или
fstorage_load_section), а так же при вызове fstorage_close вызываются
предоставленные пользователем функции для чтения или записи данных. 

Для потоковой обработки секции пользователь должен заполнить
структуру

    struct fstorage_stream_section_config {

        void *context;

        int (* on_read)   (struct fstorage_stream_section_config *fscc, 
                           struct fstorage_section_access_config *fsac);

        int (* on_write)  (struct fstorage_stream_section_config *fscc, 
                           struct fstorage_section_access_config *fsac);

        int (* on_destroy)(struct fstorage_stream_section_config *fscc);
    };

Метод on_read вызывается при чтении секции (инициированным
fstorage_section_load). Метод on_write вызывается при записи секции
(во время fstorage_close). Метод on_destroy вызывается при уничтожении
секции и должен освободить собственные данные, связанные с данной
секцией (доступ к этим данным пользователь получает через указатель
context).

Во время вызова on_read или on_write данным функциям передается
структура 

    struct fstorage_section_access_config {

        fstorage_section *fss;

        /* read access functions */
        int (* read)   (struct fstorage_section_access_config *fsac, void *buf, size_t nbytes);

        /* write access functions */
        int (* write)  (struct fstorage_section_access_config *fsac, void *buf, size_t nbytes);
        int (* sync)   (struct fstorage_section_access_config *fsac);

    };

которая используется для чтения или записи данных из хранилища. Чтобы
прочитать данные используется метод read, записать --- write. Их
семантика аналогична системным функциям read(2) и write(2), кроме
первого аргумента, куда должна быть передана полученный функциями
on_read и on_write указатель fsac. 

ЗАМЕЧАНИЕ. На текущий момент собственной буферизации в функциях
fsac->read и fsac->write не предусмотрено, каждый их вызов
транслируется в соответствующий системный вызов. То есть, каждый
вызов приводит к переключению режима процесса (в режим ядра) и вызов
fsac->write на каждый байт по-отдельности не будет эффективным. 

В случае возникновения ошибки, функции on_read и on_write должны
вернуть соответствующую FSTORAGE_ERROR (FSTORAGE_ERROR_READ или
FSTORAGE_ERROR_WRITE). Если чтение (запись) была завершена успешно,
функции должны вернуть FSTORAGE_OK.

После заполнения конфигурации потоковой секции ее можно установить в
хранилище при помощи вызова

    int fstorage_section_stream(fstorage_section *fss, struct fstorage_stream_section_config *fssc);

В случае передачи NULL в качестве аргумента fssc секция перестает быть
потоковой. 

Потоковая секция может быть заргужена несколько раз при помощи вызовов
fstorage_section_load. 

Примеры организации функций конфигурации потоковых секций:

static int section_on_write(struct fstorage_stream_section_config *fscc, struct fstorage_section_access_config *fsac)
{
    fsac->write(fsac, "data", sizeof("data"));

    return FSTORAGE_OK;
}

static int section__on_destroy(struct fstorage_stream_section_config *fscc)
{
    if(fscc->context) free(fscc->context);

    return FSTORAGE_OK;
}

static int section_on_read(struct fstorage_stream_section_config *fscc, struct fstorage_section_access_config *fsac)
{
    int  read_result;
    char buf[1024];

    for( ; ; )
        {
            read_result = fsac->read(fsac, buf, sizeof(buf));
            if(read_result <= 0)
                break;

            printf("section_on_read: Read data from the section: \"%.*s\"\n", read_result, buf);

            if(read_result < sizeof(buf))
                break;
        }

    return read_result < 0 ? FSTORAGE_ERROR_READ : FSTORAGE_OK;
}
