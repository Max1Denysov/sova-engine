#ifndef __csDataPack_h__
#define __csDataPack_h__

/**
 *  Подключение необходимых внешних библиотек.
 */
#include <errno.h>

// @todo remove this ifdef.
#ifndef CSDATA_EXTENDED
#  define CSDATA_EXTENDED
#endif //CSDATA_EXTENDED

#include "CSData.hpp"

// Получение версии протокола упаковки данных.
const char * csDataPackVersion();


/***************************************************************************************************

    Флаги управляющие упаковкой данных.

***************************************************************************************************/
/**
 *  На данный момент установка любого из флагов CSDATAPACK_SPLIT или CSDATAPACK_JOIN равносильна
 * установке флага CSDATAPACK_FULL.
 */
// Разрезать слишком большие данные.
#define CSDATAPACK_SPLIT 1
// Объединять слишком маленькие данные.
#define CSDATAPACK_JOIN  2
// Упаковывать и слишком большие и слишком маленькие данные.
#define CSDATAPACK_FULL ( CSDATAPACK_SPLIT | CSDATAPACK_JOIN )


/***************************************************************************************************

    Функции настройки размера передаваемых пакетов.

***************************************************************************************************/
/**
 *  Функция возвращает максимально допустимый размер аттрибута в структуре csdata_data_t,
 * порождаемой функцией csDataPack.
 */
size_t GetMaxChunkSize();
/**
 *  Функция устанавливает максимально допустимый размер аттрибута в структуре csdata_data_t,
 * порождаемой функцией csDataPack. Но при этом, если aNewMaxChunkSize больше чем 2^16, то
 * максимально допустимый размер аттрибута будет установлен в 2^16. Аналогично, если
 * aNewMaxChunkSize меньше чем 2^4, то максимальный размер аттрибута будет установлен в 2^4.
 *
 * @param aNewMaxChunkSize - новое значение для максимально допустимого размера аттрибута.
 */
#ifdef __cplusplus
extern "C"
{
#endif
void SetMaxChunkSize( size_t aNewMaxChunkSize );
#ifdef __cplusplus
}
#endif


#ifdef __cplusplus
/***************************************************************************************************

     Функции упаковки и распаковки с возможностью использования внешнего реаллокатора памяти.
   С++ версия.

***************************************************************************************************/
/** Подключение менеджера памяти. **/
//#include <nMemoryAllocator/nMemoryAllocator.hpp>

/**
 *  Упаковка подготовленных для отправки данных. Сгенерированные функцией данные, в случае
 * использования не полной упаковки, могут иметь прямые ссылки на элементы исходной структуры
 * aSource. Body не передается!
 *  Вся память выделяется через aAllocator.
 *
 * @param aSource - исходные данные для упаковки.
 * @param aAllocator - ссылка на менеджер памяти.
 * @param aDataPackFlags - флаги, определяющие тип упаковки.
 */
csdata_data_t * csDataPack( csdata_data_t * aSource, nMemoryAllocator & aAllocator, int aDataPackFlags );
/**
 *  Распаковка полученных данных. Сгенерированные функцией данные могут иметь прямые ссылки на
 * элементы исходной структуры aSource, если не использован флаг aFullAllocate в значении true.
 *  Вся память выделяется через aAllocator.
 *
 * @param aSource - исходные данные для распаковки.
 * @param aAllocator - ссылка на менеджер памяти.
 * @param aFullAllocate - флаг, указывающий, что нужно копировать всю информацию из упакованной
 *                       структуры, а не использовать ее по ссылке.
 */
csdata_data_t * csDataUnPack( csdata_data_t * aSource, nMemoryAllocator & aAllocator, bool aFullAllocate = false );

#else
/***************************************************************************************************

    Вызовы функций упаковки и распаковки без возможности использования реаллокатора памяти.
   C версия. В данном случае аллокатор создается сам по себе и память освобождается путем вызова
   соответствующих функций.

***************************************************************************************************/
/**
 *  Упаковка подготовленных для отправки данных. Сгенерированные функцией данные, в случае
 * использования не полной упаковки, могут иметь прямые ссылки на элементы исходной структуры
 * aSource. Body не передается!
 *  Вся память выделяется через статический nMemoryAllocator.
 *
 * @param aSource - исходные данные для упаковки.
 * @param aDataPackFlags - флаги, определяющие тип упаковки.
 */
csdata_data_t * csDataPack( csdata_data_t * aSource, int aDataPackFlags );
/**
 *  Распаковка полученных данных. Сгенерированные функцией данные могут иметь прямые ссылки на
 * элементы исходной структуры aSource, если не использован флаг aFullAllocate в значении true.
 *  Вся память выделяетсячерез статический nMemoryAllocator.
 *
 * @param aSource - исходные данные для упаковки.
 * @param aFullAllocate - флаг, указывающий, что нужно копировать всю информацию из упакованной
 *                       структуры, а не использовать ее по ссылке. TRUE = 1, FALSE = 0.
 */
csdata_data_t * csDataUnPack( csdata_data_t * aSource, int aFullAllocate );


/**
 *  Очистка памяти статического аллокатора. После вызова этой функции аллокатор начинает
 * использовать ранее выделенную память для новых выделений, поэтому все ранее полученные данные
 * становятся не валидными.
 */
void csAllocatorReset();
/**
 *  Фактическое освобождение памяти аллокатором.  После вызова этой функции все ранее полученные
 * данные становятся не валидными.
 */
void csAllocatorFree();


/**
 *  Настройка шага выделения памяти. Шаг выделения памяти статического аллокатора nMemoryAllocator
 * устанавливается в значение aNewMemoryStep.
 *
 * @param aNewMemoryStep - новое значение для шага выделения памяти.
 */
void csAllocatorSetMemoryStep( unsigned int aNewMemoryStep );
// Получение общего размера выделенной стаическим nMemoryAllocator'ом памяти.
size_t csAllocatorAllocatedMemorySize();

#endif //__cplusplus

#endif // __csDataPack_h__
